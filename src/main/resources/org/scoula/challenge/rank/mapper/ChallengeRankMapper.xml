<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">

<mapper namespace="org.scoula.challenge.rank.mapper.ChallengeRankMapper">

    <!-- 현재 랭킹 조회 -->
    <select id="getCurrentChallengeRanks"
            resultType="org.scoula.challenge.rank.dto.ChallengeRankResponseDTO">
        SELECT
            u.id                              AS userId,
            COALESCE(us.nickname, u.nickname) AS nickname,
            cr.`rank`                         AS rank,
            uc.actual_value                   AS actualValue
        FROM challenge_rank cr
                 JOIN user_challenge uc ON uc.id = cr.user_challenge_id
                 JOIN user u            ON u.id = uc.user_id
                 LEFT JOIN user_status us ON us.id = u.id
        WHERE uc.challenge_id = #{challengeId}
        ORDER BY cr.`rank` ASC
    </select>

    <!-- 특정 챌린지 랭크 전체 삭제(비상용) -->
    <delete id="clearCurrentChallengeRanks">
        DELETE cr
        FROM challenge_rank cr
        JOIN user_challenge uc ON uc.id = cr.user_challenge_id
        WHERE uc.challenge_id = #{challengeId}
    </delete>

    <!-- (레거시) 단순 insert -->
    <insert id="insertChallengeRank">
        INSERT INTO challenge_rank (user_challenge_id, `rank`, actual_value, updated_at)
        VALUES (#{userChallengeId}, #{rank}, #{actualValue}, NOW())
    </insert>

    <!-- 스냅샷 읽기 -->
    <select id="getChallengeRankSnapshots"
            resultType="org.scoula.challenge.rank.dto.ChallengeRankSnapshotResponseDTO">
        SELECT
            u.id                              AS userId,
            COALESCE(us.nickname, u.nickname) AS nickname,
            crs.`rank`                        AS rank,
            crs.actual_value                  AS actualValue,
            crs.month                         AS month,
            crs.is_checked                    AS isChecked
        FROM challenge_rank_snapshot crs
            JOIN user_challenge uc ON crs.user_challenge_id = uc.id
            JOIN user u            ON u.id = uc.user_id
            LEFT JOIN user_status us ON us.id = u.id
        WHERE crs.month = #{month}
        ORDER BY crs.`rank` ASC
    </select>

    <!-- 스냅샷 저장 -->
    <insert id="insertChallengeRankSnapshot">
        INSERT INTO challenge_rank_snapshot
        (user_challenge_id, month, `rank`, actual_value, is_checked, created_at)
        VALUES
            (#{userChallengeId}, #{month}, #{rank}, #{actualValue}, 0, NOW())
    </insert>

    <!-- 참가자 POJO 매핑 (setter 방식) -->
    <resultMap id="participantInfoMap"
               type="org.scoula.challenge.rank.model.ParticipantInfo">
        <result property="userChallengeId" column="user_challenge_id"/>
        <result property="actualValue"     column="actual_value"/>
    </resultMap>

    <select id="getParticipantsSortedByActualValue" resultMap="participantInfoMap">
        SELECT
            uc.id           AS user_challenge_id,
            uc.actual_value
        FROM user_challenge uc
                 JOIN challenge c ON uc.challenge_id = c.id
        WHERE c.id = #{challengeId}
          AND c.type = 'COMMON'
        ORDER BY uc.actual_value ASC,
                 (SELECT COUNT(*) FROM user_challenge sub WHERE sub.user_id = uc.user_id) DESC
    </select>

    <select id="getParticipantsSortedByActualValueInMonth" resultMap="participantInfoMap">
        SELECT
            uc.id           AS user_challenge_id,
            uc.actual_value
        FROM user_challenge uc
                 JOIN challenge c ON uc.challenge_id = c.id
        WHERE c.type = 'COMMON'
          AND DATE_FORMAT(c.start_date, '%Y-%m') = #{month}
        ORDER BY uc.actual_value ASC,
                 (SELECT COUNT(*) FROM user_challenge sub WHERE sub.user_id = uc.user_id) DESC
    </select>

    <!-- UPSERT: 삭제 없이 최신화 -->
    <insert id="upsertChallengeRank">
        INSERT INTO challenge_rank (user_challenge_id, `rank`, actual_value, updated_at)
        VALUES (#{userChallengeId}, #{rank}, #{actualValue}, NOW())
            ON DUPLICATE KEY UPDATE
                                 `rank`       = VALUES(`rank`),
                                 actual_value = VALUES(actual_value),
                                 updated_at   = NOW()
    </insert>

    <!-- 계산에서 빠진 기존 행 정리 -->
    <delete id="deleteRanksNotIn">
        DELETE cr
        FROM challenge_rank cr
        JOIN user_challenge uc ON uc.id = cr.user_challenge_id
        WHERE uc.challenge_id = #{challengeId}
        AND cr.user_challenge_id NOT IN
        <foreach item="id" collection="userChallengeIds" open="(" separator="," close=")">
            #{id}
        </foreach>
    </delete>

</mapper>
